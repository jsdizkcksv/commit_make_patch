name: Make commit on patch

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'Git 仓库 URL'
        required: true
      branch:
        description: '仓库分支 (默认使用默认分支)'
        required: false
        default: ''
      start_commit:
        description: '起始提交'
        required: true
      end_commit:
        description: '结束提交'
        required: true
      patch_type:
        description: '补丁文件类型'
        required: true
        default: '多个'
        type: choice
        options:
          - '单个'
          - '多个'

jobs:
  Make:
    runs-on: ubuntu-latest
    steps:
    - name: 检出当前仓库
      uses: actions/checkout@v4

    - name: 准备环境
      run: |
        mkdir -p source_repo
        echo "准备完成"

    - name: 克隆源仓库
      run: |
        cd source_repo
        # 使用轻量克隆
        if [ -n "${{ github.event.inputs.branch }}" ]; then
          echo "正在克隆 ${{ github.event.inputs.repo_url }} 的分支: ${{ github.event.inputs.branch }}"
          git clone --depth 100 --single-branch --branch "${{ github.event.inputs.branch }}" "${{ github.event.inputs.repo_url }}" .
        else
          echo "正在克隆 ${{ github.event.inputs.repo_url }} 的默认分支"
          git clone --depth 100 --single-branch "${{ github.event.inputs.repo_url }}" .
        fi

    - name: 生成补丁文件
      id: generate
      run: |
        cd source_repo
        
        # 获取实际提交哈希
        echo "正在解析提交哈希..."
        START_HASH=$(git rev-parse "${{ github.event.inputs.start_commit }}")
        END_HASH=$(git rev-parse "${{ github.event.inputs.end_commit }}")
        
        # 验证提交是否存在
        if ! git rev-parse --verify "$START_HASH" >/dev/null 2>&1; then
          echo "::error::起始提交 '${{ github.event.inputs.start_commit }}' 不存在"
          exit 1
        fi

        if ! git rev-parse --verify "$END_HASH" >/dev/null 2>&1; then
          echo "::error::结束提交 '${{ github.event.inputs.end_commit }}' 不存在"
          exit 1
        fi

        # 创建输出目录
        OUTPUT_DIR="../patches"
        mkdir -p "$OUTPUT_DIR"
        PATCH_COUNT=0

        # 根据选择的类型生成补丁
        if [ "${{ github.event.inputs.patch_type }}" = "单个" ]; then
          echo "正在生成单个补丁文件..."
          git diff "$START_HASH" "$END_HASH" > "$OUTPUT_DIR/combined.patch"
          PATCH_COUNT=1
          echo "已生成单个补丁文件: combined.patch"
        else
          echo "正在生成多个补丁文件..."
          # 仅在需要时获取更多历史
          if ! git merge-base --is-ancestor "$START_HASH" "$END_HASH" 2>/dev/null; then
            echo "提交范围不在当前克隆深度内，获取更多历史..."
            git fetch --unshallow || git fetch --depth=1000
          fi
          git format-patch "$START_HASH..$END_HASH" -o "$OUTPUT_DIR" --quiet
          PATCH_COUNT=$(ls -1 "$OUTPUT_DIR"/*.patch 2>/dev/null | wc -l)
          echo "已生成 $PATCH_COUNT 个补丁文件"
        fi

        # 设置输出变量
        echo "patch_dir=$OUTPUT_DIR" >> $GITHUB_OUTPUT
        echo "patch_count=$PATCH_COUNT" >> $GITHUB_OUTPUT
        echo "patch_type=${{ github.event.inputs.patch_type }}" >> $GITHUB_OUTPUT

    - name: 创建时间戳命名的 ZIP 文件
      id: create_zip
      run: |
        # 生成时间戳（年月日_时分秒）
        TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
        ZIP_NAME="patch_$TIMESTAMP.zip"
        
        # 创建 ZIP 文件
        cd ${{ steps.generate.outputs.patch_dir }}
        zip -r "../$ZIP_NAME" .
        cd ..
        
        # 设置输出变量
        echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
        echo "zip_path=$(pwd)/$ZIP_NAME" >> $GITHUB_OUTPUT
        echo "已创建 ZIP 文件: $ZIP_NAME"

    - name: 清理源仓库
      run: |
        rm -rf source_repo
        echo "已清理源仓库"

    - name: 上传 ZIP 文件到工作流产物
      uses: actions/upload-artifact@v4
      with:
        name: git-patches
        path: ${{ steps.create_zip.outputs.zip_path }}
        if-no-files-found: error

    - name: 显示结果
      run: |
        if [ "${{ github.event.inputs.patch_type }}" = "单个" ]; then
          echo "成功生成单个补丁文件: combined.patch"
        else
          echo "成功生成 ${{ steps.generate.outputs.patch_count }} 个补丁文件"
        fi
        echo "已创建 ZIP 文件: ${{ steps.create_zip.outputs.zip_name }}"
        echo "补丁文件可在工作流产物中下载"
