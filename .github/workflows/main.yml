name: Make commit on patch

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'Git 仓库 URL'
        required: true
      branch:
        description: '仓库分支 (默认使用默认分支)'
        required: false
        default: ''
      start_commit:
        description: '起始提交'
        required: true
      end_commit:
        description: '结束提交'
        required: true
      patch_type:
        description: '补丁文件类型'
        required: true
        default: '多个'
        type: choice
        options:
          - '单个'
          - '多个'

jobs:
  Make:
    runs-on: ubuntu-latest
    steps:
    - name: 检出当前仓库
      uses: actions/checkout@v4

    - name: 准备环境
      run: |
        # 创建必要的目录
        mkdir -p source_repo patches
        echo "准备完成"
        echo "当前工作目录: $(pwd)"
        echo "目录结构:"
        ls -la

    - name: 克隆源仓库
      run: |
        echo "正在克隆源仓库..."
        echo "仓库URL: ${{ github.event.inputs.repo_url }}"
        echo "分支: ${{ github.event.inputs.branch || '默认分支' }}"
        
        cd source_repo
        
        CLONE_CMD="git clone --depth 100 --single-branch"
        if [ -n "${{ github.event.inputs.branch }}" ]; then
          $CLONE_CMD --branch "${{ github.event.inputs.branch }}" "${{ github.event.inputs.repo_url }}" .
        else
          $CLONE_CMD "${{ github.event.inputs.repo_url }}" .
        fi
        
        echo "克隆完成，当前分支: $(git branch --show-current)"
        echo "最近提交: $(git log -1 --oneline)"

    - name: 生成补丁文件
      id: generate
      run: |
        cd source_repo
        
        # 获取实际提交哈希
        echo "正在解析提交哈希..."
        START_HASH=$(git rev-parse "${{ github.event.inputs.start_commit }}")
        END_HASH=$(git rev-parse "${{ github.event.inputs.end_commit }}")
        
        echo "起始提交哈希: $START_HASH"
        echo "结束提交哈希: $END_HASH"
        
        # 验证提交是否存在
        if ! git rev-parse --verify "$START_HASH" >/dev/null 2>&1; then
          echo "::error::起始提交 '${{ github.event.inputs.start_commit }}' 不存在"
          exit 1
        fi

        if ! git rev-parse --verify "$END_HASH" >/dev/null 2>&1; then
          echo "::error::结束提交 '${{ github.event.inputs.end_commit }}' 不存在"
          exit 1
        fi

        # 检查提交顺序
        if git merge-base --is-ancestor "$END_HASH" "$START_HASH"; then
          echo "::warning::提交顺序可能颠倒，交换起始和结束提交"
          TEMP_HASH=$START_HASH
          START_HASH=$END_HASH
          END_HASH=$TEMP_HASH
        fi

        # 创建输出目录
        OUTPUT_DIR="../../patches"
        mkdir -p "$OUTPUT_DIR"
        PATCH_COUNT=0

        # 根据选择的类型生成补丁
        if [ "${{ github.event.inputs.patch_type }}" = "单个" ]; then
          echo "正在生成单个补丁文件..."
          git diff "$START_HASH" "$END_HASH" > "$OUTPUT_DIR/combined.patch" || echo "生成单个补丁失败"
          
          if [ -s "$OUTPUT_DIR/combined.patch" ]; then
            PATCH_COUNT=1
            echo "已生成单个补丁文件: combined.patch"
          else
            echo "::warning::生成的单个补丁文件为空"
          fi
        else
          echo "正在生成多个补丁文件..."
          
          # 检查提交范围是否有效
          COMMIT_RANGE="$START_HASH..$END_HASH"
          echo "提交范围: $COMMIT_RANGE"
          
          # 获取提交数量
          COMMIT_COUNT=$(git rev-list --count $COMMIT_RANGE || echo 0)
          echo "范围内提交数量: $COMMIT_COUNT"
          
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "::warning::提交范围内没有提交，尝试交换顺序..."
            COMMIT_RANGE="$END_HASH..$START_HASH"
            COMMIT_COUNT=$(git rev-list --count $COMMIT_RANGE || echo 0)
            echo "交换后范围内提交数量: $COMMIT_COUNT"
          fi
          
          if [ "$COMMIT_COUNT" -gt 0 ]; then
            # 确保有足够的历史
            CURRENT_DEPTH=$(git rev-list --count HEAD)
            if [ "$COMMIT_COUNT" -gt $CURRENT_DEPTH ]; then
              echo "需要更多历史记录，当前深度: $CURRENT_DEPTH, 需要: $COMMIT_COUNT"
              git fetch --depth=$((COMMIT_COUNT + 10))
            fi
            
            # 生成补丁
            git format-patch $COMMIT_RANGE -o "$OUTPUT_DIR" --quiet
            PATCH_COUNT=$(ls -1 "$OUTPUT_DIR"/*.patch 2>/dev/null | wc -l)
            echo "已生成 $PATCH_COUNT 个补丁文件"
          else
            echo "::error::提交范围内没有有效的提交"
            echo "起始提交: $(git show -s --format='%h %s' $START_HASH)"
            echo "结束提交: $(git show -s --format='%h %s' $END_HASH)"
            exit 1
          fi
        fi

        # 设置输出变量
        echo "patch_dir=../patches" >> $GITHUB_OUTPUT
        echo "patch_count=$PATCH_COUNT" >> $GITHUB_OUTPUT
        echo "patch_type=${{ github.event.inputs.patch_type }}" >> $GITHUB_OUTPUT

    - name: 检查补丁文件
      run: |
        echo "检查补丁目录内容..."
        echo "补丁目录路径: $(pwd)/patches"
        ls -la patches || echo "补丁目录不存在"
        
        if [ -d "patches" ]; then
          echo "补丁文件列表:"
          ls -l patches/*.patch 2>/dev/null || echo "没有找到补丁文件"
        fi

    - name: 创建时间戳命名的 ZIP 文件
      id: create_zip
      run: |
        # 检查补丁目录是否存在
        if [ ! -d "patches" ]; then
          echo "::error::补丁目录不存在"
          exit 1
        fi
        
        # 检查是否有补丁文件
        PATCH_FILES=$(ls patches/*.patch 2>/dev/null | wc -l)
        if [ "$PATCH_FILES" -eq 0 ]; then
          echo "::error::没有生成任何补丁文件"
          echo "可能原因:"
          echo "1. 起始提交和结束提交相同"
          echo "2. 提交顺序错误"
          echo "3. 提交范围内没有变更"
          exit 1
        fi
        
        # 生成时间戳（年月日_时分秒）
        TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
        ZIP_NAME="patch_$TIMESTAMP.zip"
        
        # 创建 ZIP 文件
        cd patches
        zip -r "../$ZIP_NAME" .
        cd ..
        
        # 设置输出变量
        echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
        echo "zip_path=$(pwd)/$ZIP_NAME" >> $GITHUB_OUTPUT
        echo "已创建 ZIP 文件: $ZIP_NAME"

    - name: 清理源仓库
      run: |
        rm -rf source_repo
        echo "已清理源仓库"

    - name: 上传 ZIP 文件到工作流产物
      uses: actions/upload-artifact@v4
      with:
        name: git-patches
        path: ${{ steps.create_zip.outputs.zip_path }}
        if-no-files-found: error

    - name: 显示结果
      run: |
        if [ "${{ github.event.inputs.patch_type }}" = "单个" ]; then
          echo "成功生成单个补丁文件: combined.patch"
        else
          echo "成功生成 ${{ steps.generate.outputs.patch_count }} 个补丁文件"
        fi
        echo "已创建 ZIP 文件: ${{ steps.create_zip.outputs.zip_name }}"
        echo "补丁文件可在工作流产物中下载"
